\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{pdflscape}
\usepackage{tabularx}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}

\setlength{\parskip}{1.1em}

\renewcommand\contentsname{Sommaire}

\renewcommand{\thesection}{\arabic{section}}
%\renewcommand{\thesubsection}{\arabic{section}}
\newcommand\familyname{\textsc}

\title{\textbf{Modélisation des Acteurs}}
\author{Marion \familyname{Ly} \\ Thibaut \familyname{Smith}}
\date{2013 - 2014}

\begin{document}

	\maketitle

	\section{Interface pour les acteurs}

	Le module \textbf{actor\_contract} fournit à la fois la spécification d'un 
	acteur (les fonctions que l'acteur doit implémenter) et une liste de 
	fonctions exportées permettant de simplifier les actions les plus basiques 
	tels que création/recherche d'information dans les métadonnées d'un acteur.

	Voici une liste des fonctions que doivent implémenter chaque acteur pour 
	assurer une compatibilité avec le système de contrôle. 


	\subsection*{Fonction create/0}
		Cette fonction renvoi un acteur avec des valeurs mises par défaut ou
		générés aléatoirement, tels que le nom de l'acteur (en général le nom
		du module), l'identifiant de l'acteur créé (unique).

		Elle ne prend aucun argument.

	\subsection*{Fonction answer/2}
	
		Cette fonction permet de \textbf{caractériser} le comportement du 
		module en fonction d'une entrée précise (qui peut être un produit, mais
		pas nécessairement). C'est cette fonction qui doit modifier/lire le 
		produit si il y a lieu.

		Elle prend deux arguments :

		\begin{enumerate}
			\item La configuration de l'acteur
			\item La requête demandé qui s'exprime, pour toutes les 
			\textit{requêtes}, par le protocole suivant :

				\{ConfigurationActeurA, 
				\{NomActeurB, ConfigurationActeurB\},
				 Destination\}
				ActeurA correspond à l'acteur auquel on pose la requête, et 
				ActeurB correspond au flux physique, dans notre cas le produit.
				Enfin vient la destination de la requête, qui est soit dirigée
				à l'acteur suivant, soit au superviseur.
		\end{enumerate}

		 Le produit étant le seul acteur qui est un flux physique, 
		 il ne répond pas parfaitement au protocole. 
		 
		 L'interface \textbf{actor\_contract} comprend également différentes 
		 fonctions implémentées pour accéder et modifier les données des 
		 configurations ainsi que des réponses types pouvant être utilisées 
		 par chaque acteur. Il est cependant toujours possible d'annuler ce 
		 comportement via programmation.

	\subsection*{Fonction end\_physical\_work/?}
	\subsection*{Fonction end\_logical\_work/?}
	\subsection*{Fonction make\_up\_timeout\_time/0}
	\subsection*{Fonction timeout\_action/?}
	\subsection*{Fonction sending\_product/?}
	 
	\begin{landscape}
		\begin{center}
			\begin{tabularx}{1.55\textwidth}{|X|X|X|X|X|X|X|}
				\hline
				Configuration & Module & Id & opt (options) & State & Worktime & list\_data \\
				\hline
				Convoyeur & actor\_conveyor & Hasard & sortie & on/off & Temps de transport & Produits transférés \\
				\hline
				Aiguilleur & actor\_railway & Hasard & entrée/sortie/règle de priorité & {in, out} (son état physique) & Temps d'aiguillage & Produits transférés, état aiguilleur \\
				\hline
				RFID & actor\_rfid & Hasard & entrée & on/off & Temps de détection & Produits détectés\\
				\hline
				Station de travail & actor\_workstation & Hasard & entrée/sortie & on/work/off & Temps de fabrication & Liste des produits crées, avec la qualité \\
				\hline
				Produit & actor\_product & Hasard & Qualité demandée & raw/Q1/Q2/Q3 & Aucun & Emplacements parcourus \\
				\hline
				File d'attente basique & actor\_basic\_queue & Hasard & Pas d'options & on/processing/off & Temps minimum avant qu'un produit soit disponible & Liste de produits avec temps d'entrée et temps de sortie \\
				\hline
			\end{tabularx}
		\end{center}
	
	\end{landscape}

	\section{Acteurs actuellement implémentés}
	
		\subsection{Lecteur RFID}
		 	Lorsque le lecteur reçoit un produit, nous avons alors un temps de 
		 	travail, puis le lecteur enregistre alors les données du produit dans 
		 	sa base et ses données à lui dans la base du produit. Le lecteur envoie 
		 	alors l'Id du produit qu'il a lu en réponse.
		 
		\subsection{Convoyeur}
			Lorsqu'un produit arrive au convoyeur, un temps de travail se passe, 
			le temps de transport du produit. Les données du produit sont 
			enregistrées dans la base du convoyeur, celles du convoyeur dans la 
			base du produit. Le produit est alors envoyé à l'acteur suivant.

		\subsection{Aiguilleur}
			A partir du moment, où l'aiguilleur reçoit le produit, sa réponse 
			dépendra des entrées sorties de celui-ci : 
			- plusieurs entrées ou plusieurs sorties, un message est envoyé au 
			superviseur, contenant la description du conflit et les données du 
			produit et de l'aiguilleur pour que le superviseur puisse prendre 
			sa décision (un ordre de priorité contenu dans les options de 
			l'aiguilleur, et la qualité demandé du produit peut l'aider)
			- une entrée et une sortie, on ajoute le produit ainsi que l'état de 
			l'aiguilleur à la base de l'aiguilleur et on envoie 
			le produit à l'acteur suivant
			
			S'il y a eu conflit, l'aiguilleur recevra alors la décision du 
			superviseur sur l'aiguillage du produit. On pourra ajouter les 
			informations de la même façon qu'avec une entrée et une sortie. 
			L'aiguilleur changera d'état (entrée/sortie) et il y aura alors un 
			temps de travail. l'aiguilleur enverra alors ensuite le produit au 
			destinataire choisi par l'aiguilleur. Si la décision choisi est 
			identique qu'à l'état actuelle de l'aiguilleur celui-ci n'a donc pas 
			à changer d'état et il n'y a donc pas de temps de travail.

		\subsection{File d'attente basique}

		\subsection{Station de travail}
			attente des files d'attente. 
		 
		\subsection{Le produit}
			 Comme dit précédemment, le produit est un flux physique donc il 
			 ne répond pas à un protocole pour ce qui est de ses réponses au 
			 superviseur. On lui demandera alors juste de répondre par ses données. 
			 Ce type de réponses pourra aussi être utilisé par les autres acteurs 
			 si on veut récupérer/modifier certaines de leurs données de 
			 manières simplifiés.
\end{document}